# Язык CraneLang

Язык является функциональным и имеет следующие возможности:

* Именованные переменные
* Функции и рекурсия
* Файловый ввод/вывод
* Интерактивный режим
* Объекты производного типа
* Каррированые функции
* Лямбда выражения

## Режимы работы

У интерпретатора есть два режима работы - интерактивный и режим работы с исходным кодом.
В интерактивном режиме программа считывает построчно выражения из стандартного потока ввода (одна строка - одно выражение)
и выводит в стандартный поток вывода результаты выражений. В контексте одной сессии можно определять и использовать переменные.
В режиме работы с исходным кодом интерпретатор читает исходный код из заданного файла и выполняет код оттуда.
По умолчанию запускается интерактивный режим.

Из командной строки язык запускается следующим образом:
```
CraneLang.exe [OPTIONS]
```
Со следующими опциями:

* `-f <имя_файла>` : обозначает, что включен режим работы с исходным кодом и выполняться будет код из заданного файла.
* `-i <имя_файла>` : (доступна только если был указана опция `-f`) обозначает, что ввод будет осуществляться из заданного файла.
* `-o <имя_файла>` : (доступна только если был указана опция `-f`) обозначает, что вывод будет осуществляться в заданный файл.

## Типы данных

В языке есть следующие типы данных:

 * int - целочисленный тип
 * string - строковый тип
 * function - тип функций
 * complex_object - производный тип, 
 * writer - потоковый вывод
 * reader - потоковый ввод
 * null - тип, имеющий единственное значение `$null`
 * undefined - тип, схожий с `$null` по функционалу, но семантически обозначает отсутствие определения какой-либо переменной.
 Например, если у нас нет не было объявления переменной `a`, но мы попробовали взять ее значение в коде, нам вернется значение
 `$undefined`. То же самое будет если мы попытаемся получить поле объекта производного типа, которого не существует.

Примеры объявлений переменных разных типов данных:
```
let var_int = 3;
let var_string = "some text";
let var_null = $null;
let var_undefined = $undefined;
let var_func = lam x -> (+ x 2);
let var_complex_obj = {
    field1 : var_int,
    field2 : 0,
    field3 : {
        a : {
            b: 3,
            c: $null
        },
        b : 11
    }
};
let var_reader = $file_reader "in.txt";
let var_writer = $file_writer "out.txt";
```

## Let

Присваивает значение переменной или создает функцию.
```
let a = 3;
let b = $file_reader "in.txt"
let square x = (* x x);
let sum x y = (+ x y);
```

## Операторы

В языке поддерживаются следующие операторы:
```
+, -, /, *, <, >, <=, >=, !=, =
```

Все операторы являются бинарными.
Применение выглядит вот так:
```
(оператор выр1 выр2);
```

Примеры применения операторов:
```
let val_4 = (+ 2 2);
let val_0 = (- 5 5);
let var_cmp_1 = (= 3 3);
```

## Условная конструкция

Выглядит так:
```
if выр1 then выр2 else выр3;
```

Вычисляет `выр1`, если оно равно нулю, то выполняет `выр3`, иначе выполняет `выр2`.

Примеры:
```
let is_a_three = if (= a 3) then "a is three" else "a is not three";
```

## Лямбда выражения

Создает анонимную функцию. Выглядит так:
```
lam имя -> выр;
```

Примеры:
```
let twice = lam x -> (* x 2);
```

## Применение функций

Применяет функцию к аргументу. Если функция является вложенной, можно указать несколько аргументов, тогда они будут применяться
по очереди:
```
(имя_функции выр1 выр2 ...)
```

Пример:
```
let sum x y = (+ x y);
let sq = lam x -> (* x x);

let var_5 = (sum 2 3);
let var_4 = (sq 2);
```

## Локальный let (loclet)

Создает временную переменную.
Выглядит так:
```
loclet имя = выр1 in выр2;
```
Вычисляет `выр2`, подставляя в него вместо `имя` результат `выр1`.

Пример:
```
let var_4 = 
    loclet var_2 = 2 in (+ var_2 var_2);
```

## Ввод/Вывод

В языке есть два способа ввода и вывода информации.

1. Встроенные функции `print`, `println`, `read_string`, `read_int`:
Функции `print` и `println` вызываются как и обычные функции, принимают на вход сколько угодно аргументов и печатают
результаты выражений по очереди в стандартный вывод. Отличие `println` от `print` - переход на новую строку после вывода.
Чтобы прочитать строку или число из стандартного ввода надо просто поставить ключевое слово `read_string` или `read_int` в
нужное место.  
Примеры:

```
let n = read_int;
(println "N squared is " (* n n) );
let s = read_string;
(print s);
```

2. С помощью объектов потокового ввода и вывода. С помощью этого можно писать и читать только в файлы и из файлов. 
При этом нельзя открыть один и тот же файл дважды. Если при запуске файлы, которые вы хотите открыть, были указаны в опции
`-i` или `-o`, то их также нельзя открыть.
Потоковый ввод может читать только строки, так что можно воспользоваться встроенной фукнцией `to_int` для преобразования строки
в число:
```
to_int выражение;
```

Чтобы использовать потоковый ввод и вывод, сначала надо создать объект читателя или писателя:
```
$file_reader имя_файла;
$file_writer имя_файла;
``` 

Для чтения и записи используются следующие конструкции:
```
$read объект_читателя;
$write выражение $to объект_писателя;
```

Пример:
```
let r = $file_reader "in.txt";
let w = $file_writer "out.txt";
let n = to_int $read r;
let new_n = (+ n 2);
$write new_n $to w;
```

## Запросы

Позволяет получить какую-либо информацию об объекте.
Выглядит так:
```
? выражение запрос;
```
Возвращает 1, если `выражение` удовлетворяет запросу, 0 - иначе.

Список запросов:

* `undef` - является ли объект `undefined`
* `def` - определен ли объект
* `null` - равен ли объект `null`
* `int` - является ли объект числом
* `function` - является ли объект функцией
* `string` - является ли объект строкой
* `com_obj` - имеет ли объект производный тип

Примеры:
```
if ? a def then (println "a is defined") else (println "a is not defined");
```

## Производный тип данных

Объекты производного типа данных являются по сути объектом, хранящих некоторое (возможно нулевое) число полей, у которых есть
имена и значение. Значением поля может быть любой объект, в том числе и объект производного типа. Благодаря этому можно
реализовать рекурсивные структуры данных. Чтобы получить значение поля объекта надо написать имя объекта и имя поля через точку.
Примеры:
```
let a = {
    b : {
        c : 3
    }
};

let var_3 = a.b.c;
```

## Факториал
```
let fact n = 
    if (= n 0) then 1 else (* n (fact (- n 1) ) );

let n = read_int;

(println (fact n) );
```

## Примеры

Примеры программ находятся в папке examples.
